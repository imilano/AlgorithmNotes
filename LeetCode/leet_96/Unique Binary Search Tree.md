### 题目描述

```
96. Unique Binary Search Trees
Medium

Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n?
```

### 题解

简单来讲，就是给你n个节点，问你一共可以形成几棵结构不同的二叉查找树。很显然，可以用动态规划来解决。

在LeetCode评论区看到一个非常棒的解法。问题重点在于组建结构不同的二叉查找树。首先从根节点入手，假设选择节点i为根节点，那么很自然就能想到i之前的节点「0...i-1」构成根节点的左子树，而「i+1,....n」构成根节点的右子树。每次选取的根节点不同，所以构成的BST肯定是unique的。

我们定义两个函数：

- G(n)：表示n个节点可以构成的Unique BST的数量
- f(i,n)，1<=i<=n:表示选择节点i作为根节点，节点序列从1到n可以构成的Unique BST数量。

很明显，我们的目标是G(n)，但是G(n)可以从f(i,n)获得：

```
G(n) = f(0,n)+f(1,n)+ ...+f(n,n)									#公式1
```

很明显，1个节点和0个节点可以构成的子树数量都是1，所以G（1）=G(0)=1。

从序列「1...n」中挑选出节点i作为根节点，那么以i作为根节点的Unique BST的数量就是左子树和右子树的笛卡尔积。举例来说，举例来说，F(3，7），表示以3作为根节点，[1,2]作为左子树，[4,5,6,7]作为右子树所能构成的Unique BST。这里比较有技巧的地方是，我们可以把[1,2]所能构成的Unique BST简化为G(2)，而把[4,5,6,7]所能构成的Unique BST称为G(4)，所以最后的结果就是F(3,7)=G(2) *G(4)。同理可以对其他节点归结为同样的形式，所以有：

```
f(i,n) = G(i-1) * G(n-i)					 (i<=i<=n)							# 公式2
```

综合上面两个公式，可以得到:

```
G(n) = G(0)*G(n-1) + G(1)*G(n-2)+...+G(n-1)*G(0)
```

