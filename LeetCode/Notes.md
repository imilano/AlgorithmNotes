# Notes

字符串匹配类型的题目一般可以使用动态规划和状态机来解决。


## 单调栈

单调栈是在栈先进后出的基础上额外再添加一个特性：从栈顶到栈底的元素是严格递增（或递减的）。

具体过程如下：
- 对于单调递增栈，若当前进栈元素为`e`，从栈顶开始遍历元素，把小于等于`e`的元素弹出栈，直到遇到一个大于`e`的元素或者栈为空为止，然后再把`e`压入栈中。
- 对于单调递减栈，则每次弹出的是大于等于`e`的元素。

**单调递增栈可以找到左起第一个比当前数小的元素，单调递增栈可以找到左起第一个比当前元素大的元素。**

线性的时间复杂度是其最大的优势，每个数字只进栈并处理一次，而解决问题的核心就在处理这块，当前数字如果破坏了单调性，就会触发处理栈顶元素的操作，而触发数字有时候是解决问题的一部分.

很多的单调栈的题目并不是存储实际的数字，而是存储表示该数字的坐标。


## BFS
BFS 调用的时候需要注意，由于我们会删除队列中的元素，所以队列的长度经常会在变化，故而不能直接在for循环的条件判断中直接使用len(nums)，而应该提前将其计算好，作为一个常数来使用（代表当前层的节点数量）。


## BS

BS中如何决定是使用left < right 还是left  <= right 呢？ 当你想要查找某个特定target的时候，使用left <= end，一般你会在循环中不断的对mid和target进行检查；
当你不是想找到特定元素的时候，使用left < right，比如说当你想找到最小元素或者边界值的时候，在这种情况下，每一次循环都会reduce space，由于循环在left == right 时候
终止，所以最后剩下的元素就是你想查找的边界。一般循环结束后你还需要对left进行处理，因为left == right时循环就结束了，并没有对left进行处理。

## Go
- string('a')会直接得到a，而strconv.Itoa('a')只会得到98.
- int和int32不是同一个类型。int的实际大小与平台相关，比如在32位上就是32位，在64位上就是64位。官方只保证他和uint有同样的size。也就说说，int可以用来存储比uint32或者int32还要大的数字。