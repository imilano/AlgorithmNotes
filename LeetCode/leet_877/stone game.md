## 石头游戏

###  题目描述

```
你和你的朋友面前有一排石头堆，用一个数组 piles 表示，piles[i] 表示第 i 堆石子有多少个。你们轮流拿石头，一次拿一堆，但是只能拿走最左边或者最右边的石头堆。所有石头被拿完后，谁拥有的石头多，谁获胜。

石头总数是奇数，因而不会有平局出现。堆数数是偶数。
```

### 题目分析

### 二维DP

**dp数组**

首先看dp数组的定义，定义dp数组如下：

```
dp[i][j].first 	表示先手对于[i...j]这堆石头，能获得的最高的的石头数。
dp[i][j].second	表示后手对于[i...j]这堆石头，能获得的最高的额石头数。


举例理解一下，假设 piles = [3, 9, 1, 2]，索引从 0 开始
dp[0][1].fir = 9 意味着：面对石头堆 [3, 9]，先手最终能够获得 9 分。
dp[1][3].sec = 2 意味着：面对石头堆 [9, 1, 2]，后手最终能够获得 2 分。
```



**状态转移方程**

可以看到，当我们不断的进行选择时，触发状态转移的因素有如下几个，一个是石头的堆数量i和j，另一个就是当前进行选择的人。三个变量之间的关系如下：

```
dp[i][j].first OR dp[i][j].second
0 <= i < length 
i <= j < length
```

对于每个状态，可以做的选择有两个，一个是取最左边的石头，一个是取最右边的石头。

```
for i in [0,N]:
	for j in [i,N]:
		for who in [first,second]:
			dp[i][j].who = max(选最左边的石头，选最右边的石头)
```

另外，可以清楚的看到，先手的动作对后手会有后效性。简单来说，当先手选择了第i堆之后，后手就只能从i + 1 开始进行选择。那么，如何在状态转移中表现出这个影响呢？

```
# 不管先手选择了最左边的石头还是最右边的石头，由于后效行，本次的先手会沦为下一次的后手
dp[i][j].first = max(piles[i]+dp[i+1][j].second, piles[j] + dp[i][j-1].second)


# 如果先手选择了最左边的石头i，那么后手只能从i+1开始进行选择，
# 并且它就是[i+1...j]中进行选择的先手
if 先手选择了最左边的石头：
	dp[i][j].second = dp[i+1][j].first
	
if 先手选择了最右边的石头：
	d[i][j].second = dp[i][j-1].first
	
```

### base condition

```
dp[i][j].fir = piles[i]
dp[i][j].sec = 0
其中 0 <= i == j < n
# 解释：i 和 j 相等就是说面前只有一堆石头 piles[i]
# 那么显然先手的得分为 piles[i]
# 后手没有石头拿了，得分为 0
```

可以看到，计算`dp[i][j]`时需要用到`dp[i+1][j]`和`dp[i][j-1]`，也就是说，计算本位置的值需要用到左侧的值和下侧的值。因而，填充dp表时，，是斜着填充的。

![](/Users/randy/go/src/lightsinger.life/algorithm/leetcode/leet_877/3.png)

### 数学方法

游戏只会出现两个解结果，分别是输和赢。玩家1先开始拿，任意取取那一边都可以。由于玩家1占了先手，玩家2只能别无选择，只能取另一种方法。这样，玩家1始终掌握整个游戏的节奏。一旦游戏结束，如果玩家1手中的石头多余玩家2 手中的石头，那么玩家1赢了；否则，因为堆数是偶数，取的左边或者取右边是可以对调的两个操作，所以玩家1完全可以采取相反的策略，也会赢。也就说，玩家1由于占先手，他总是有赢的办法。

```go
func stoneGame(stone [int]) bool {
  return true
}
```

也可以从位置开始考虑，位置只有奇数和偶数两种，分别计算奇数位和偶数位的石头总和s1和s2，如果s1大于s2，那么玩家1只需要总是取奇数位的数即可，反之取偶数即可，也就是说，玩家1还是赢。

### 一维DP

