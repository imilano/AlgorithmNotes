# 01背包问题

## Description 

有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使价值总和最大。每件物品要么全部装入背包，要么不装入，01背包不允许出现部分装入的情况。

## Solution

### 使用二维数组的动态规划

本题是经典的动态规划问题。我们可以使用一个二维数组dp辅助计算。定义dp[i][j]表示选择前i件物品并且此时背包容量为j时所能得到的最大价值。

状态转移是背包问题的核心。对于一件物品i，它有两种可能，要么放入背包，要么不放入背包。这两种选择对应两种转移状态。对于dp[i][j]，如果把第i个物品放入背包，那么dp[i][j]=dp[i-1][j-c[i]]+w[i];而如果不放入背包，那么dp[i][j]=dp[i-1][j];而base case为dp[0][j]=dp[i][0]=0;

综上所述，就有C++代码为：

```c++
int knapsack() {
        for ( int i =0;i < numbers;i++)  // 物品数量
          for (int j = 0; j < capacities;j++) // 容量数
          if (j < weight[i])  // 装不进
            dp[i][j] = dp[i - 1][j];
          else
            dp[i][j] = std::max(dp[i-1][j], dp[i - 1][j - weight[i]] + value[i]);  // 装得进，取大者
        return dp[N][N];
}
```

此算法时间复杂度为$O(n^2)$,空间复杂度也为$O(n^2)$。

### 使用滚动数组的背包问题

实际上，从上面的递推公式可以看到，当前状态下的背包容量只和前一次的背包容量有关，也就说说，dp[i][j]只和dp[i-1][x]（x属于1到j）相关，因此，可以使用一维数组，从而达到优化空间的目的。状态转移方程变为dp[j]=max{dp[j],dp[j-w[i]]+v[i]}，需要注意的是，第一个dp[j]表示循环i的dp[i][j]；而第二个dp[j]表示的是循环i-1的dp[i-1][j-w[i]]。正因为二者的状态不同，所以才需要采用逆序的遍历方式，否则会修改先dp[i]的值，造成计算错误。并且，状态转移方程，每一次推导dp[i][j]是通过dp[i-1][j-w(i)]来推导的，所以一维数组中j的扫描顺序应该从大到小(capacity到0)，否者前一次循环保存下来的值将会被修改，从而造成错误。

优化后的方程如下：

```c++
int OptimizedKnapsack() {
        for (int i=1;i<= numbers;i++)
          for (int j = capacities; j >= 0;j--) 
          if j >= w[i] dp[j] = std::max(dp[j], dp[j - w[i]] + v[i]);

        return dp[N];
}

```
很容易看到，时间复杂度不变，空间复杂度为$O(n)$。